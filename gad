#!/usr/bin/python
"""
Group accessable directories - Allows a group of users read and/or write
  access to a directory tree, by setting the owners and ACL permissions
  apropriately.

Version 0.1.0
"""
# Copyright (C) 2008 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.

# Dependencies: python-pylibacl

import os
import sys
import grp
import stat
import posix1e


debug = True
simulate = False

def log_dbg(str):
	global debug
	if debug:
		sys.stderr.write('gad: debug: %s\n' % str)

def set_log_dbg(flag):
	global debug
	debug = flag

def set_simulate(flag):
	global simulate
	simulate = flag

class TreeModifier(object):
	def __init__(self, *args, **kwargs):
		self.tree_base = kwargs['tree_base']
		self.ignore_dirs = kwargs['ignore_dirs']
		self.ignore_links = kwargs.get('ignore_links', True)

	def is_path_ignored(self, path):
		"""Determines whether the passed path matches an ignored directory
		or is a symbolic link (and we ignore symbolic links)."""
		if self.ignore_links and os.path.islink(path):
			return True
		for idir in self.ignore_dirs:
			ipath = os.path.join(self.tree_base, idir)
			if ipath == path:
				return True
		return False

	def filter_ignored_paths(self, root_path, names):
		"""Filters out the ignored paths."""
		return filter(
				lambda name: not self.is_path_ignored(
						os.path.join(root_path, name)),
				names)

	def apply(self, perm_handler):
		perm_handler.assert_dir_perms(self.tree_base)
		for root, dirs, files in os.walk(self.tree_base):
			dirs = self.filter_ignored_paths(root, dirs)
			files = self.filter_ignored_paths(root, files)

			for name in files:
				path = os.path.join(root, name)
				perm_handler.assert_file_perms(path)

			for name in dirs:
				path = os.path.join(root, name)
				perm_handler.assert_dir_perms(path)


class StackedPermHandler(object):
	def __init__(self, *args, **kwargs):
		self.handlers = []

	def append(self, handler):
		self.handlers.append(handler)

	def assert_file_perms(self, path):
		for handler in self.handlers:
			handler.assert_file_perms(path)

	def assert_dir_perms(self, path):
		for handler in self.handlers:
			handler.assert_dir_perms(path)


class AssertGroupOwner(object):
	"""
	Makes sure that all files and directories are owned by a specified
	group.
	"""
	def __init__(self, *args, **kwargs):
		self.gid = grp.getgrnam(kwargs['owner']).gr_gid

	def assert_group_owner(self, path):
		global simulate
		si = os.stat(path)
		if si.st_gid != self.gid:
			log_dbg("Changing gid of %s from %d to %d" % (path, si.st_gid,
					self.gid))
			if not simulate:
				os.chown(path, -1, self.gid)

	assert_file_perms = assert_group_owner
	assert_dir_perms = assert_group_owner


class AssertDirStickyGroup(object):
	"""
	Makes sure that all directories have the group sticky bit set.
	"""
	def assert_file_perms(self, path):
		pass

	def assert_dir_perms(self, path):
		global simulate
		si = os.stat(path)
		if not (stat.S_IMODE(si.st_mode) & stat.S_ISGID):
			log_dbg("Adding sticky gid to dir %s" % path)
			if not simulate:
				os.chmod(path, stat.S_IMODE(si.st_mode) | stat.S_ISGID)

def permset_bits(permset):
	bits = 0
	for perm in [posix1e.ACL_READ, posix1e.ACL_WRITE, posix1e.ACL_EXECUTE]:
		if permset.test(perm):
			bits |= perm
	return bits

def bits_as_permarray(bits):
	perms = []
	for perm in [posix1e.ACL_READ, posix1e.ACL_WRITE, posix1e.ACL_EXECUTE]:
		if bits & perm:
			perms.append(perm)
	return perms

class SimpleAclEntry(object):
	def __init__(self, acl, entry):
		self.acl = acl
		self.entry = entry

	def __str__(self):
		return "%s in %s" % (str(self.entry), str(self.acl))

	def get_permbits(self):
		return permset_bits(self.entry.permset)

	def fix_perms(self, required_perms = [], forbidden_perms = []):
		for perm in required_perms:
			if not self.entry.permset.test(perm):
				self.entry.permset.add(perm)
				self.acl.modified = True
		for perm in forbidden_perms:
			if self.entry.permset.test(perm):
				self.entry.permset.delete(perm)
				self.acl.modified = True

	def delete(self):
		self.acl.acl.delete_entry(self.entry)
		self.acl.modified = True

	def get_tag_type(self):
		return self.entry.tag_type
	def set_tag_type(self, tag_type):
		self.entry.tag_type = tag_type
	tag_type = property(get_tag_type, set_tag_type)

	def get_qualifier(self):
		return self.entry.qualifier
	def set_qualifier(self, qualifier):
		self.entry.qualifier = qualifier
	qualifier = property(get_qualifier, set_qualifier)

	def get_permset(self):
		return self.entry.permset
	def set_permset(self, permset):
		self.entry.permset = permset
	permset = property(get_permset, set_permset)

class SimpleAcl(object):
	def __init__(self, acl):
		self.acl = acl
		self.modified = False

	def entries(self):
		for entry in self.acl:
			yield SimpleAclEntry(self, entry)

	def is_modified(self):
		return self.modified

	def _create_entry(self, type):
		entry = posix1e.Entry(self.acl)
		entry.tag_type = type
		self.modified = True
		return SimpleAclEntry(self, entry)

	def _get_entry(self, type, qual):
		for entry in self.entries():
			if entry.tag_type == type \
					and entry.qualifier == qual:
				return entry
		return None

	def has_group(self, gid):
		return self._get_entry(posix1e.ACL_GROUP, gid) is not None

	def get_group(self, gid):
		entry = self._get_entry(posix1e.ACL_GROUP, gid)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_GROUP)
			entry.qualifier = gid
		return entry


	def _get_entry_obj(self, type):
		for entry in self.entries():
			if entry.tag_type == type:
				return entry
		return None

	def get_user_obj(self):
		entry = self._get_entry_obj(posix1e.ACL_USER_OBJ)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_USER_OBJ)
		return entry

	def get_group_obj(self):
		entry = self._get_entry_obj(posix1e.ACL_GROUP_OBJ)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_GROUP_OBJ)
		return entry

	def get_other(self):
		entry = self._get_entry_obj(posix1e.ACL_OTHER)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_OTHER)
		return entry

	def get_mask(self):
		entry = self._get_entry_obj(posix1e.ACL_MASK)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_MASK)
		return entry


	def _filter_entries(self, type, quals):
		for entry in self.entries():
			if entry.tag_type == type:
				if entry.qualifier not in quals:
					log_dbg("Deleting %s" % entry)
					entry.delete()

	def filter_groups(self, gids = []):
		self._filter_entries(posix1e.ACL_GROUP, gids)

	def filter_users(self, uids = []):
		self._filter_entries(posix1e.ACL_USER, uids)

	def recalc_to_mask(self):
		"""Adjust all permissions to the effective permissions as dictacted by
		the mask."""
		mask = self._get_entry_obj(posix1e.ACL_MASK)
		if mask is None:
			# There is no mask, so all perms are the effective perms.
			return

		# Calculate which perms are masked out by the ACL_MASK entry.
		forbidden_perms = bits_as_permarray(~mask.get_permbits())

		# Remove the masked-out permissions.
		for entry in self.entries():
			if entry.tag_type == posix1e.ACL_MASK:
				continue
			entry.fix_perms(forbidden_perms = forbidden_perms)

	def calc_mask(self):
		"""Recalculates the permission mask and returns whether the mask
		actually changed."""
		old_mask = self.get_mask().get_permbits()
		self.acl.calc_mask()
		if old_mask != self.get_mask().get_permbits():
			self.modified = True
			return True
		return False

	def valid(self):
		return self.acl.valid()

class SimpleAccessAcl(SimpleAcl):
	def __init__(self, file_path):
		self.path = file_path
		acl = posix1e.ACL(file = self.path)
		super(SimpleAccessAcl, self).__init__(acl)

	def __str__(self):
		return "access ACL for \"%s\"" % self.path

	def apply(self):
		global simulate
		if not simulate:
			self.acl.applyto(self.path, posix1e.ACL_TYPE_ACCESS)
		self.modified = False

class SimpleDefaultAcl(SimpleAcl):
	def __init__(self, file_path):
		self.path = file_path
		acl = posix1e.ACL(filedef = self.path)
		super(SimpleDefaultAcl, self).__init__(acl)

	def __str__(self):
		return "default ACL for \"%s\"" % self.path

	def apply(self):
		global simulate
		if not simulate:
			self.acl.applyto(self.path, posix1e.ACL_TYPE_DEFAULT)
		self.modified = False

class AssertWriteAndReadGroups(object):
	"""
	Makes sure that the owning group has write access and the specified rgroups
	have read access (as well as directory listing permissions).

	Apropriately set the default ACLs on the directories.
	"""
	def __init__(self, *args, **kwargs):
		if 'rgroups' in kwargs and kwargs['rgroups'] is not None:
			self.rgids = map(lambda gname: grp.getgrnam(gname).gr_gid,
					kwargs['rgroups'])
		else:
			self.rgids = []

	def assert_acl_file_entries(self, curr_acl):
		curr_acl.filter_groups(self.rgids)
		curr_acl.filter_users([])

		# Group owner should be able to read and write.
		entry = curr_acl.get_group_obj()
		entry.fix_perms(required_perms = [posix1e.ACL_READ, posix1e.ACL_WRITE])

		# Others should not be able to do anything.
		entry = curr_acl.get_other()
		entry.fix_perms(forbidden_perms = [posix1e.ACL_READ, posix1e.ACL_WRITE,
				posix1e.ACL_EXECUTE])

		for rgid in self.rgids:
			# Rgroup should be able to read but not write.
			entry = curr_acl.get_group(rgid)
			entry.fix_perms(required_perms = [posix1e.ACL_READ],
					forbidden_perms = [posix1e.ACL_WRITE])

		if curr_acl.is_modified():
			curr_acl.calc_mask()
		return curr_acl.is_modified()

	def assert_acl_dir_entries(self, curr_acl):
		# Group owner should be able to execute.
		entry = curr_acl.get_group_obj()
		entry.fix_perms(required_perms = [posix1e.ACL_EXECUTE])

		for rgid in self.rgids:
			# Rgroup should be able to execute.
			entry = curr_acl.get_group(rgid)
			entry.fix_perms(required_perms = [posix1e.ACL_EXECUTE])

		if curr_acl.is_modified():
			curr_acl.calc_mask()
		return curr_acl.is_modified()

	def assert_base_dir_perms(self, curr_acl):
		if curr_acl.valid():
			return False

		entry = curr_acl.get_user_obj()
		entry.permset.add(posix1e.ACL_READ)
		entry.permset.add(posix1e.ACL_WRITE)
		entry.permset.add(posix1e.ACL_EXECUTE)

		curr_acl.get_group_obj()
		curr_acl.get_other()
		return True

	def assert_file_perms(self, path):
		curr_acl = SimpleAccessAcl(path)
		curr_acl.recalc_to_mask()
		if self.assert_acl_file_entries(curr_acl):
			log_dbg("updated ACL for file %s" % path)
			curr_acl.apply()

	def assert_dir_perms(self, path):
		curr_acl = SimpleAccessAcl(path)
		curr_acl.recalc_to_mask()
		if self.assert_acl_file_entries(curr_acl) \
				| self.assert_acl_dir_entries(curr_acl):
			log_dbg("updated ACL for dir %s" % path)
			curr_acl.apply()

		curr_acl = SimpleDefaultAcl(path)
		curr_acl.recalc_to_mask()
		if self.assert_base_dir_perms(curr_acl) \
				| self.assert_acl_file_entries(curr_acl) \
				| self.assert_acl_dir_entries(curr_acl):
			log_dbg("updated default ACL for dir %s (%d)" % (path,
					curr_acl.valid()))
			curr_acl.apply()


def make_group_accessable(tree_base, wgroup, rgroups = [], ignore_dirs = [],
		ignore_links = True):
	sph = StackedPermHandler()
	sph.append(AssertGroupOwner(owner = wgroup))
	sph.append(AssertDirStickyGroup())
	sph.append(AssertWriteAndReadGroups(rgroups = rgroups))

	tm = TreeModifier(tree_base = tree_base, ignore_dirs = ignore_dirs,
			ignore_links = ignore_links)
	tm.apply(sph)


if __name__ == '__main__':
	# Dictionary of all methods available to the configuration file.
	available = {
			'make_group_accessable': make_group_accessable,
			'set_log_dbg': set_log_dbg,
			'set_simulate': set_simulate,
			}
	execfile(sys.argv[1], available)

# vim: set ts=4:
