#!/usr/bin/python
"""
Group accessable directories - Allows a group of users read and/or write
  access to a directory tree, by setting the owners and ACL permissions
  apropriately.
"""
# Copyright (C) 2008 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.

import os
import sys
import grp
import stat
import posix1e


class TreeModifier(object):
	def __init__(self, *args, **kwargs):
		self.tree_base = kwargs['tree_base']
		self.ignore_dirs = kwargs['ignore_dirs']

	def is_path_ignored(self, path):
		"""Determines whether the passed path matches an ignored directory."""
		for idir in self.ignore_dirs:
			ipath = os.path.join(self.tree_base, idir)
			if ipath == path:
				return True
		return False

	def filter_ignored_paths(self, root_path, names):
		"""Filters out the ignored paths."""
		return filter(
				lambda name: not self.is_path_ignored(
						os.path.join(root_path, name)),
				names)

	def apply(self, perm_handler):
		perm_handler.assert_dir_perms(self.tree_base)
		for root, dirs, files in os.walk(self.tree_base):
			dirs = self.filter_ignored_paths(root, dirs)
			files = self.filter_ignored_paths(root, files)

			for name in files:
				path = os.path.join(root, name)
				perm_handler.assert_file_perms(path)

			for name in dirs:
				path = os.path.join(root, name)
				perm_handler.assert_dir_perms(path)


class StackedPermHandler(object):
	def __init__(self, *args, **kwargs):
		self.handlers = []

	def append(self, handler):
		self.handlers.append(handler)

	def assert_file_perms(self, path):
		for handler in self.handlers:
			handler.assert_file_perms(path)

	def assert_dir_perms(self, path):
		for handler in self.handlers:
			handler.assert_dir_perms(path)


class AssertGroupOwner(object):
	"""
	Makes sure that all files and directories are owned by a specified
	group.
	"""
	def __init__(self, *args, **kwargs):
		self.gid = grp.getgrnam(kwargs['owner']).gr_gid

	def assert_group_owner(self, path):
		si = os.stat(path)
		if si.st_gid != self.gid:
			print "Changing gid of %s from %d to %d" % (path, si.st_gid,
					self.gid)
			os.chown(path, -1, self.gid)

	assert_file_perms = assert_group_owner
	assert_dir_perms = assert_group_owner


class AssertDirStickyGroup(object):
	"""
	Makes sure that all directories have the group sticky bit set.
	"""
	def assert_file_perms(self, path):
		pass

	def assert_dir_perms(self, path):
		si = os.stat(path)
		if not (stat.S_IMODE(si.st_mode) & stat.S_ISGID):
			print "Adding sticky gid to dir %s" % path
			os.chmod(path, stat.S_IMODE(si.st_mode) | stat.S_ISGID)

class SimpleAcl(object):
	def __init__(self, acl):
		self.acl = acl
		self.modified = False

	def is_modified(self):
		return self.modified

	def _create_entry(self, type):
		entry = posix1e.Entry(self.acl)
		entry.tag_type = type
		self.modified = True
		return entry

	def _get_entry(self, type, qual):
		for entry in self.acl:
			if entry.tag_type == type \
					and entry.qualifier == qual:
				return entry
		return None

	def has_group(self, gid):
		return self._get_entry(posix1e.ACL_GROUP, gid) is not None

	def get_group(self, gid):
		entry = self._get_entry(posix1e.ACL_GROUP, gid)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_GROUP)
			entry.qualifier = gid
		return entry


	def _get_entry_obj(self, type):
		for entry in self.acl:
			if entry.tag_type == type:
				return entry
		return None

	def get_user_obj(self):
		entry = self._get_entry_obj(posix1e.ACL_USER_OBJ)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_USER_OBJ)
		return entry

	def get_group_obj(self):
		entry = self._get_entry_obj(posix1e.ACL_GROUP_OBJ)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_GROUP_OBJ)
		return entry

	def get_other(self):
		entry = self._get_entry_obj(posix1e.ACL_OTHER)
		if entry is None:
			entry = self._create_entry(posix1e.ACL_OTHER)
		return entry


	def fix_perms(self, entry, required_perms = [], forbidden_perms = []):
		for perm in required_perms:
			if not entry.permset.test(perm):
				entry.permset.add(perm)
				self.modified = True
		for perm in forbidden_perms:
			if entry.permset.test(perm):
				entry.permset.delete(perm)
				self.modified = True


	def _filter_entries(self, type, quals):
		for entry in self.acl:
			if entry.tag_type == type:
				if entry.qualifier not in quals:
					print "Deleting %s" % entry
					self.acl.delete_entry(entry)
					self.modified = True

	def filter_groups(self, gids = []):
		self._filter_entries(posix1e.ACL_GROUP, gids)

	def filter_users(self, uids = []):
		self._filter_entries(posix1e.ACL_USER, uids)

class AssertWriteAndReadGroups(object):
	"""
	Makes sure that the owning group has write access and the specified rgroup
	has read access (as well as directory listing permissions).

	Apropriately set the default ACLs on the directories.
	"""
	def __init__(self, *args, **kwargs):
		if 'rgroup' in kwargs and kwargs['rgroup'] is not None:
			self.rgid = grp.getgrnam(kwargs['rgroup']).gr_gid
		else:
			self.rgid = None

	def assert_acl_file_entries(self, curr_acl):
		scurr_acl = SimpleAcl(curr_acl)
		scurr_acl.filter_groups([self.rgid])
		scurr_acl.filter_users([])

		# Group owner should be able to read and write.
		entry = scurr_acl.get_group_obj()
		scurr_acl.fix_perms(entry, required_perms = [posix1e.ACL_READ,
				posix1e.ACL_WRITE])

		# Others should not be able to do anything.
		entry = scurr_acl.get_other()
		scurr_acl.fix_perms(entry, forbidden_perms = [posix1e.ACL_READ,
				posix1e.ACL_WRITE, posix1e.ACL_EXECUTE])

		if self.rgid is not None:
			# Rgroup should be able to read but not write.
			entry = scurr_acl.get_group(self.rgid)
			scurr_acl.fix_perms(entry, required_perms = [posix1e.ACL_READ],
					forbidden_perms = [posix1e.ACL_WRITE])

		if scurr_acl.is_modified():
			curr_acl.calc_mask()
		return scurr_acl.is_modified()

	def assert_acl_dir_entries(self, curr_acl):
		scurr_acl = SimpleAcl(curr_acl)

		# Group owner should be able to execute.
		entry = scurr_acl.get_group_obj()
		scurr_acl.fix_perms(entry, required_perms = [posix1e.ACL_EXECUTE])

		if self.rgid is not None:
			# Rgroup should be able to execute.
			entry = scurr_acl.get_group(self.rgid)
			scurr_acl.fix_perms(entry, required_perms = [posix1e.ACL_EXECUTE])

		if scurr_acl.is_modified():
			curr_acl.calc_mask()
		return scurr_acl.is_modified()

	def assert_base_dir_perms(self, curr_acl):
		if curr_acl.valid():
			return False

		scurr_acl = SimpleAcl(curr_acl)
		entry = scurr_acl.get_user_obj()
		entry.permset.add(posix1e.ACL_READ)
		entry.permset.add(posix1e.ACL_WRITE)
		entry.permset.add(posix1e.ACL_EXECUTE)

		scurr_acl.get_group_obj()
		scurr_acl.get_other()
		return True

	def assert_file_perms(self, path):
		curr_acl = posix1e.ACL(file = path)
		if self.assert_acl_file_entries(curr_acl) \
			| self.assert_acl_dir_entries(curr_acl):
			print "updated ACL for %s" % path
			curr_acl.applyto(path, posix1e.ACL_TYPE_ACCESS)

	def assert_dir_perms(self, path):
		curr_acl = posix1e.ACL(file = path)
		if self.assert_acl_file_entries(curr_acl) \
				| self.assert_acl_dir_entries(curr_acl):
			print "updated ACL for %s" % path
			curr_acl.applyto(path, posix1e.ACL_TYPE_ACCESS)

		curr_acl = posix1e.ACL(filedef = path)
		if self.assert_base_dir_perms(curr_acl) \
				| self.assert_acl_file_entries(curr_acl) \
				| self.assert_acl_dir_entries(curr_acl):
			print "updated default ACL for %s (%d)" % (path, curr_acl.valid())
			curr_acl.applyto(path, posix1e.ACL_TYPE_DEFAULT)


def make_group_accessable(tree_base, wgroup, rgroup = None, ignore_dirs = []):
	sph = StackedPermHandler()
	sph.append(AssertGroupOwner(owner = wgroup))
	sph.append(AssertDirStickyGroup())
	sph.append(AssertWriteAndReadGroups(rgroup = rgroup))

	tm = TreeModifier(tree_base = tree_base, ignore_dirs = ignore_dirs)
	tm.apply(sph)


if __name__ == '__main__':
	make_group_accessable(tree_base = './testtree',
			wgroup = 'cdrom',
			rgroup = 'src',
			ignore_dirs = ['bla', 'oink/foo'])
	sys.exit(0)

# vim: set ts=4:
