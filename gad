#!/usr/bin/python
"""
Group accessable directories - Allows a group of users read and/or write
  access to a directory tree, by setting the owners and ACL permissions
  apropriately.

Version 0.3.1
"""
# Copyright (C) 2008 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.

# Dependencies: simpleacl

import os
import sys
import grp
import pwd
import stat
import simpleacl
import os.path
from optparse import OptionParser


# Crude locking and global state.

def log_dbg(str):
    global debug
    if debug:
        sys.stderr.write('gad: debug: %s\n' % str)

def set_log_dbg(flag):
    global debug
    debug = flag

def set_simulate(flag):
    global simulate
    simulate = flag


class TreeModifier(object):
    """The tree modifier walks through a tree a modifies the file and directory
    permissions by calling a specified permission handler.

    The modifier supports recursive or non-recursive mode, a path ignore and an
    element ignore list."""

    def __init__(self, *args, **kwargs):
        self.tree_base = kwargs['tree_base']
        self.ignore_paths = kwargs['ignore_paths']
        self.ignore_elements = kwargs['ignore_elements']
        self.ignore_links = kwargs.get('ignore_links', True)
        self.ignore_base = kwargs.get('ignore_base', False)
        self.recursive = kwargs.get('recursive', True)

    def _is_path_ignored(self, path):
        """Determines whether the passed path matches an ignored directory
        or is a symbolic link (and we ignore symbolic links)."""
        if self.ignore_links and os.path.islink(path):
            return True
        for idir in self.ignore_paths:
            ipath = os.path.join(self.tree_base, idir)
            if ipath == path:
                return True
        return False

    def _filter_ignored_paths(self, root_path, names):
        """Filters out the ignored paths."""
        for name in names[:]:
            if name in self.ignore_elements or \
                    self._is_path_ignored(os.path.join(root_path, name)):
                names.remove(name)

    def apply(self, perm_handler):
        """Applies the passed permission handler perm_handler to all elements
        of the tree modifier's tree."""
        if not self.ignore_base:
            if os.path.isdir(self.tree_base):
                perm_handler.assert_dir_perms(self.tree_base)
            else:
                perm_handler.assert_file_perms(self.tree_base)
        if self.recursive and os.path.isdir(self.tree_base):
            for root, dirs, files in os.walk(self.tree_base):
                self._filter_ignored_paths(root, files)
                for name in files:
                    path = os.path.join(root, name)
                    perm_handler.assert_file_perms(path)

                self._filter_ignored_paths(root, dirs)
                for name in dirs:
                    path = os.path.join(root, name)
                    perm_handler.assert_dir_perms(path)


class StackedHandler(object):
    def __init__(self, handlers = None):
        if handlers is None:
            self.handlers = []
        else:
            self.handlers = handlers

    def append(self, handler):
        self.handlers.append(handler)

class StackedPermHandler(StackedHandler):
    """Forwards a permission handler request to a stored list of permission
    handlers. New permission handlers can be added via the append method."""

    def assert_file_perms(self, path):
        """Assert permissions on the file specified by path. Achieves this by
        calling all stored handlers."""
        for handler in self.handlers:
            handler.assert_file_perms(path)

    def assert_dir_perms(self, path):
        """Assert permissions on the directory specified by path. Achieves this
        by calling all stored handlers."""
        for handler in self.handlers:
            handler.assert_dir_perms(path)

class AssertUserOwnerInGroup(object):
    """Makes sure that the file/directory unix owner belongs to a certain
    group. If it doesn't, the owner is switched to a safe user."""

    def __init__(self, *args, **kwargs):
        # Cache all valid uids of the safe group.
        self.member_uids = map(lambda user: pwd.getpwnam(user).pw_uid,
                grp.getgrnam(kwargs['group']).gr_mem)
        # Replacement uid
        self.safe_uid = pwd.getpwnam(kwargs['safe_user']).pw_uid

    def assert_user_owner_in_group(self, path):
        global simulate
        si = os.stat(path)
        if si.st_uid != self.safe_uid and not si.st_uid in self.member_uids:
            log_dbg("Changing uid of %s from %d to %d" % (path, si.st_uid,
                    self.safe_uid))
            if not simulate:
                os.chown(path, self.safe_uid, -1)

    # Handle both files and directories.
    assert_file_perms = assert_user_owner_in_group
    assert_dir_perms = assert_user_owner_in_group

class AssertGroupOwner(object):
    """Makes sure that all files and directories are owned by a specified
    group."""
    def __init__(self, *args, **kwargs):
        self.gid = grp.getgrnam(kwargs['owner']).gr_gid

    def assert_group_owner(self, path):
        global simulate
        si = os.stat(path)
        if si.st_gid != self.gid:
            log_dbg("Changing gid of %s from %d to %d" % (path, si.st_gid,
                    self.gid))
            if not simulate:
                os.chown(path, -1, self.gid)

    assert_file_perms = assert_group_owner
    assert_dir_perms = assert_group_owner

class AssertDirStickyGroup(object):
    """Makes sure that all directories have the group sticky bit set."""
    def assert_file_perms(self, path):
        pass

    def assert_dir_perms(self, path):
        global simulate
        si = os.stat(path)
        if not (stat.S_IMODE(si.st_mode) & stat.S_ISGID):
            log_dbg("Adding sticky gid to dir %s" % path)
            if not simulate:
                os.chmod(path, stat.S_IMODE(si.st_mode) | stat.S_ISGID)

class StackedAccessAclHandlers(StackedHandler):
    """
    """

    def assert_file_perms(self, path):
        curr_acl = simpleacl.SimpleAccessAcl(path)
        curr_acl.recalc_to_mask()
        updated = False
        for handler in self.handlers:
            updated |= handler.assert_acl_file_perms(curr_acl)
        if updated:
            log_dbg("updated ACL for file %s" % path)
            curr_acl.apply()

    def assert_dir_perms(self, path):
        curr_acl = simpleacl.SimpleAccessAcl(path)
        curr_acl.recalc_to_mask()
        updated = False
        for handler in self.handlers:
            updated |= handler.assert_acl_file_perms(curr_acl)
            updated |= handler.assert_acl_dir_perms(curr_acl)
        if updated:
            log_dbg("updated ACL for dir %s" % path)
            curr_acl.apply()

class StackedDefaultAclHandlers(StackedHandler):
    """
    """

    def assert_file_perms(self, path):
        # Files don't have default ACLs. Do nothing.
        pass

    def assert_dir_perms(self, path):
        curr_acl = simpleacl.SimpleDefaultAcl(path)
        curr_acl.recalc_to_mask()
        updated = False
        for handler in self.handlers:
            updated |= handler.assert_acl_file_perms(curr_acl)
            updated |= handler.assert_acl_dir_perms(curr_acl)
        if updated:
            log_dbg("updated default ACL for dir %s (%d)" % (path,
                    curr_acl.valid()))
            curr_acl.apply()

class AssertBasicValidAcl(object):
    def assert_acl_file_perms(self, curr_acl):
        return False

    def assert_acl_dir_perms(self, curr_acl):
        if curr_acl.valid():
            return False

        # By default, the owner should be able to do everything.
        entry = curr_acl.get_user_obj()
        entry.permset.add(simpleacl.ACL_READ)
        entry.permset.add(simpleacl.ACL_WRITE)
        entry.permset.add(simpleacl.ACL_EXECUTE)

        # Using the get methods assures that the elements exist.
        curr_acl.get_group_obj()
        curr_acl.get_other()

        return True

class AssertWriteAndReadGroups(object):
    """Makes sure that the owning group has write access and the specified
    rgroups have read access (as well as directory listing permissions).

    Apropriately set the default ACLs on the directories."""

    def __init__(self, *args, **kwargs):
        if 'rgroups' in kwargs and kwargs['rgroups'] is not None:
            self.rgids = map(lambda gname: grp.getgrnam(gname).gr_gid,
                    kwargs['rgroups'])
        else:
            self.rgids = []

    def assert_acl_file_perms(self, curr_acl):
        curr_acl.filter_groups(self.rgids)
        curr_acl.filter_users([])

        # Use the owner's permissions as a permission mask for the write and
        # read groups.
        user_obj_entry = curr_acl.get_user_obj()
        wgroup_perms = []
        rgroup_perms = []
        if user_obj_entry.permset.test(simpleacl.ACL_READ):
            wgroup_perms.append(simpleacl.ACL_READ)
            rgroup_perms.append(simpleacl.ACL_READ)
        if user_obj_entry.permset.test(simpleacl.ACL_EXECUTE):
            wgroup_perms.append(simpleacl.ACL_EXECUTE)
            rgroup_perms.append(simpleacl.ACL_EXECUTE)
        if user_obj_entry.permset.test(simpleacl.ACL_WRITE):
            # Note: Read-only groups do not get write permission.
            wgroup_perms.append(simpleacl.ACL_WRITE)

        # Group owner (write group) ...
        entry = curr_acl.get_group_obj()
        entry.set_perms(perms = wgroup_perms)

        # Read groups ...
        for rgid in self.rgids:
            entry = curr_acl.get_group(rgid)
            entry.set_perms(perms = rgroup_perms)

        # Others should not be able to do anything.
        entry = curr_acl.get_other()
        entry.set_perms([])

        if curr_acl.is_modified():
            curr_acl.calc_mask()
        return curr_acl.is_modified()

    def assert_acl_dir_perms(self, curr_acl):
        return False


def make_group_accessable(tree_base, wgroup, rgroups = [], ignore_paths = [],
        ignore_elements = [], ignore_links = True, safe_user = None,
        recursive = True, ignore_base = False):
    global simulate
    if simulate:
        log_dbg('only simulating commands for %s' % tree_base)

    sph = StackedPermHandler()
    if safe_user is not None:
        sph.append(AssertUserOwnerInGroup(group = wgroup,
                safe_user = safe_user))
    sph.append(AssertGroupOwner(owner = wgroup))
    sph.append(AssertDirStickyGroup())

    awarg = AssertWriteAndReadGroups(rgroups = rgroups)

    sdah = StackedDefaultAclHandlers()
    sdah.append(AssertBasicValidAcl())
    sdah.append(awarg)

    sph.append(sdah)
    saah = StackedAccessAclHandlers()
    saah.append(awarg)
    sph.append(saah)

    tm = TreeModifier(tree_base = tree_base, ignore_paths = ignore_paths,
            ignore_elements = ignore_elements, ignore_links = ignore_links,
            ignore_base = ignore_base, recursive = recursive)
    tm.apply(sph)

def process_config_file(file):
    log_dbg('processing %s' % file)
    # Dictionary of all methods available to the configuration file.
    available = {
            'make_group_accessable': make_group_accessable,
            'set_log_dbg': set_log_dbg,
            'set_simulate': set_simulate,
            }
    execfile(file, available)

def main():
    global debug
    global simulate

    parser = OptionParser("usage: %prog [options] config-files..")
    parser.add_option("-d", "--debug",
            action = "store_true", dest = "debug",
            help = "enable debugging output",
            default = False)
    parser.add_option("-s", "--simulate",
            action = "store_true", dest = "simulate",
            help = "only simulate the actions",
            default = False)
    (options, args) = parser.parse_args()
    if len(args) == 0:
        parser.error("need at least one configuration file to run")
    simulate = options.simulate
    debug = options.debug

    for conf_file in args:
        process_config_file(conf_file)

if __name__ == '__main__':
    main()

# vim:set tabstop=8 softtabstop=4 shiftwidth=4 et:
